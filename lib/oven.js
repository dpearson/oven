// Generated by CoffeeScript 1.7.1

/*
	Copyright 2012-2014 David Pearson.
	All rights reserved.
 */

(function() {
  var build, child_process, clc, clean, cmd, coffee, coffeelint, coffeelintConfig, dir, dirs, fileIs, fs, genCpyFunc, genList, lint, lintAndBuild, loc, ovenfile, ovenfilePath, pkg, proc, runCmd, runSilent, total, watch, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1;

  child_process = require("child_process");

  clc = require("cli-color");

  fs = require("fs");

  _ref = require("./cmd"), runCmd = _ref.runCmd, runSilent = _ref.runSilent;

  pkg = __filename.substring(0, __filename.length - 12);

  coffee = "" + pkg + "/node_modules/coffee-script/bin/coffee";

  coffeelint = "" + pkg + "/node_modules/coffeelint/bin/coffeelint";

  coffeelintConfig = "" + pkg + "/coffeelint.json";

  genCpyFunc = function(filename, dest) {
    return function(curr, prev) {
      if (curr.mtime.getTime() !== prev.mtime.getTime()) {
        console.log("cp " + filename + " " + dest);
        return child_process.exec("cp " + filename + " " + dest);
      }
    };
  };

  fileIs = function(name, type) {
    return name.toString().indexOf(type) === name.toString().length - type.length;
  };

  build = function(src, bin, bare) {
    var opts;
    opts = ["-o", bin, "-c", src];
    if (bare) {
      opts.unshift("-b");
    }
    return runCmd(coffee, opts, function(code) {
      var binPath, f, srcFiles, srcPath, stat, _i, _len, _results;
      if (code === 0) {
        srcFiles = fs.readdirSync(src);
        _results = [];
        for (_i = 0, _len = srcFiles.length; _i < _len; _i++) {
          f = srcFiles[_i];
          if (f.toString() === ".DS_Store") {
            continue;
          }
          srcPath = src + "/" + f;
          binPath = bin + "/" + f;
          stat = fs.statSync(srcPath);
          if (stat.isDirectory()) {
            if (!fs.existsSync(binPath)) {
              fs.mkdirSync(binPath);
            }
            _results.push(build(srcPath, binPath));
          } else if (fileIs(f, ".js") || fileIs(f, ".json")) {
            _results.push(runCmd("cp", [srcPath, binPath], function(code) {
              if (code !== 0) {
                console.log("Error copying " + srcPath);
                return process.exit(-1);
              }
            }));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      } else {
        return process.exit(-1);
      }
    });
  };

  lintAndBuild = function(src, bin, bare, cb) {
    return lint(src, true, function(code) {
      if (code !== -900) {
        build(src, bin, bare);
        return cb(true);
      } else {
        return cb(false);
      }
    });
  };

  watch = function(src, bin, bare) {
    var binPath, f, opts, srcFiles, srcPath, stat, _i, _len, _results;
    opts = ["-w", "-o", bin, "-c", src];
    if (bare) {
      opts.unshift("-b");
    }
    runCmd(coffee, opts);
    srcFiles = fs.readdirSync(src);
    _results = [];
    for (_i = 0, _len = srcFiles.length; _i < _len; _i++) {
      f = srcFiles[_i];
      if (f.toString() === ".DS_Store") {
        continue;
      }
      srcPath = src + "/" + f;
      binPath = bin + "/" + f;
      stat = fs.statSync(srcPath);
      if (stat.isDirectory()) {
        if (!fs.existsSync(binPath)) {
          fs.mkdirSync(binPath);
        }
        _results.push(build(srcPath, binPath));
      } else if (fileIs(f, ".js") || fileIs(f, ".json")) {
        _results.push(fs.watchFile(srcPath, genCpyFunc(srcPath, binPath)));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  clean = function(bin) {
    var binFiles, binPath, f, stat, _i, _len, _results;
    binFiles = fs.readdirSync(bin);
    _results = [];
    for (_i = 0, _len = binFiles.length; _i < _len; _i++) {
      f = binFiles[_i];
      binPath = bin + "/" + f;
      stat = fs.statSync(binPath);
      if (stat.isDirectory()) {
        clean(binPath);
        _results.push(fs.rmdirSync(binPath));
      } else {
        _results.push(fs.unlink(binPath));
      }
    }
    return _results;
  };

  genList = function(folder, type) {
    var contents, f, files, list, path, stat, _i, _len;
    list = [];
    files = fs.readdirSync(folder);
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      f = files[_i];
      if (f.toString() === ".DS_Store") {
        continue;
      }
      path = folder + "/" + f;
      stat = fs.statSync(path);
      if (stat.isDirectory()) {
        contents = genList(path, type);
        list.push.apply(list, contents);
      } else if (fileIs(f, type)) {
        list.push(path);
      }
    }
    return list;
  };

  lint = function(src, quiet, cb) {
    var args, fileList;
    args = ["-f", coffeelintConfig];
    fileList = genList(src, ".coffee");
    args.push.apply(args, fileList);
    if (!quiet) {
      if (cb != null) {
        return runCmd(coffeelint, args, cb);
      } else {
        return runCmd(coffeelint, args);
      }
    } else {
      return runSilent(coffeelint, args, function(code) {
        if (code === 0) {
          console.log(clc.green("Lint succeeded."));
        } else {
          console.log(clc.red("Lint failed; run 'oven lint' for details."));
        }
        if (cb != null) {
          return cb(code);
        }
      });
    }
  };

  loc = function(src, bin) {
    var count, file, fileList, l, lineNoWhite, lines, _i, _j, _len, _len1;
    count = 0;
    fileList = genList(src, ".coffee");
    for (_i = 0, _len = fileList.length; _i < _len; _i++) {
      file = fileList[_i];
      lines = fs.readFileSync(file).toString().split("\n");
      for (_j = 0, _len1 = lines.length; _j < _len1; _j++) {
        l = lines[_j];
        lineNoWhite = l.replace("/ /g", "").replace("/\t/g", "");
        if (lineNoWhite !== "" && lineNoWhite.substring(0, 1) !== "#") {
          count += 1;
        }
      }
    }
    return count;
  };

  cmd = process.argv[2];

  dirs = [];

  ovenfile = null;

  ovenfilePath = process.cwd() + "/Ovenfile";

  if (fs.existsSync(ovenfilePath)) {
    ovenfile = JSON.parse(fs.readFileSync(ovenfilePath));
    dirs = ovenfile.directories;
  } else {
    console.log("An Ovenfile wasn't found in the current directory!");
    process.exit(-1);
  }

  switch (cmd) {
    case "build":
      for (_i = 0, _len = dirs.length; _i < _len; _i++) {
        dir = dirs[_i];
        if (!dir.skipLint) {
          lintAndBuild(dir.src, dir.bin, dir.bare, function(success) {
            if (success) {
              return console.log(clc.green("Build succeeded."));
            } else {
              return console.log(clc.red("Build failed."));
            }
          });
        } else {
          build(dir.src, dir.bin, dir.bare);
          console.log(clc.green("Build succeeded."));
        }
      }
      break;
    case "watch":
      for (_j = 0, _len1 = dirs.length; _j < _len1; _j++) {
        dir = dirs[_j];
        watch(dir.src, dir.bin, dir.bare);
      }
      break;
    case "clean":
      for (_k = 0, _len2 = dirs.length; _k < _len2; _k++) {
        dir = dirs[_k];
        clean(dir.bin);
      }
      break;
    case "lint":
      for (_l = 0, _len3 = dirs.length; _l < _len3; _l++) {
        dir = dirs[_l];
        lint(dir.src, false);
      }
      break;
    case "loc":
      total = 0;
      for (_m = 0, _len4 = dirs.length; _m < _len4; _m++) {
        dir = dirs[_m];
        total += loc(dir.src, dir.bin);
      }
      console.log(total);
      break;
    default:
      if ((ovenfile != null ? (_ref1 = ovenfile.scripts) != null ? _ref1[cmd] : void 0 : void 0) != null) {
        proc = child_process.exec(ovenfile.scripts[cmd]);
        proc.stdout.pipe(process.stdout);
        proc.stderr.pipe(process.stderr);
      } else {
        console.log("Unrecognized command " + cmd);
      }
  }

}).call(this);
